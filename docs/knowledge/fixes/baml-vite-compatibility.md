# BAML/Vite Compatibility Fix

**Date**: 2026-01-30
**Issue**: `ReferenceError: exports is not defined` when using BAML client in Vite SSR

## Problem

The `@boundaryml/baml` package is a CommonJS module (uses `exports` and `module.exports`), but Vite's SSR module runner expects ES modules. When the generated BAML client code tried to import named exports from the package, Vite couldn't properly handle the CommonJS to ESM conversion, resulting in errors like:

```
ReferenceError: exports is not defined
```

and

```
Named export 'HTTPRequest' not found. The requested module '@boundaryml/baml' is a CommonJS module
```

## Root Cause

The generated BAML client code (`baml_client/*.ts`) imports from `@boundaryml/baml` using ES module syntax:

```typescript
import { ThrowIfVersionMismatch } from "@boundaryml/baml";
import { HTTPRequest, toBamlError, ... } from "@boundaryml/baml";
```

But the actual `@boundaryml/baml` package is CommonJS. Vite's SSR module runner has issues transforming these imports, especially for packages with complex exports and native bindings.

## Solution

Created an ESM compatibility wrapper that uses Node.js's `createRequire` to load the CommonJS module and re-export it as ESM.

### Files Created

1. **`src/lib/baml-compat.mjs`** - ESM wrapper that:
   - Uses `createRequire` to load the CommonJS BAML module
   - Re-exports all named exports as ESM
   - Provides a default export

2. **`src/lib/baml-compat.cjs`** - CommonJS helper (fallback, not currently used)

### Vite Configuration

Updated `vite.config.ts` to alias all `@boundaryml/baml` imports to point to the compatibility wrapper:

```typescript
resolve: {
  alias: {
    '@boundaryml/baml': resolve(__dirname, 'src/lib/baml-compat.mjs')
  }
}
```

This ensures that whenever the BAML client code imports from `@boundaryml/baml`, it actually gets the ESM-compatible wrapper instead of the raw CommonJS package.

## How It Works

1. BAML client code imports: `import { ThrowIfVersionMismatch } from "@boundaryml/baml"`
2. Vite resolves this to: `src/lib/baml-compat.mjs`
3. The wrapper uses `createRequire` to load the actual CommonJS package
4. The wrapper re-exports all named exports as ESM
5. Vite can now properly handle the imports in SSR

## Testing

Verified the fix by testing the `/api/recap` endpoint:

```bash
curl -X POST http://localhost:5173/api/recap \
  -H "Content-Type: application/json" \
  -d '{"boxScore": {...}}'
```

Before: `ReferenceError: exports is not defined`
After: API works correctly (only fails if ANTHROPIC_API_KEY is missing, which is expected)

## Alternative Approaches Tried

1. **`ssr.external`** - Marking BAML as external didn't work because Vite still tried to transform imports
2. **`ssr.noExternal`** - Forcing Vite to bundle BAML failed because it couldn't handle the CommonJS exports
3. **`optimizeDeps.include`** - Pre-bundling didn't solve the SSR issue
4. **`resolve.conditions`** - Setting Node.js conditions didn't help with the import transformation

The wrapper approach is the most reliable solution because it completely bridges the CommonJS/ESM gap at the import boundary.

## Maintenance Notes

- The wrapper (`baml-compat.mjs`) needs to export all named exports that BAML provides
- If BAML adds new exports in future versions, they need to be added to the wrapper
- The generated BAML client code should not be modified (it's regenerated by `baml-cli generate`)
- This solution works with BAML v0.218.1 and should work with future versions

## See Also

- BAML documentation: https://docs.boundaryml.com
- Vite SSR documentation: https://vitejs.dev/guide/ssr
- Node.js ESM/CommonJS interop: https://nodejs.org/api/esm.html
